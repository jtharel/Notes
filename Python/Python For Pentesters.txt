Virtualenv in Python - allows you to run different versions of python


name = "jimmy"
id(name)		will show address in memory
hex(id(name))	will show it in hex

name.__repr__	will show it as well



name = u'jimmy'  defines it as unicode

str(name)	converts it to a string

unicode("jimmy") back to unicode


name.split('a') 	will use 'a' as a delimiter for breaking up text strings

name.replace('jim', 'jimbo')



Strings Formatting:

ip = "192.168.1.10"
line = "Crack this IP: %s" % ip



Lists: (Collection of objects)

mylist = [1,2,3]

len(mylist)		returns 3
mylist[1]		returns 2


mylist.append(4)		adds 4 to the end of mylist [1,2,3,4]

mylist.pop		pops out the last item in the list, in this case 4



Help:	show help for methods:
help(string.replace)
	i.e. help(mylist)
		help(mylist.sort)



File I/O in Python:

open(file_name, access_mode, buffering)
open("jimmy.txt", "w")	
		access_mode ("w" = write; creates file, overwrites existing file)
		access_mode ("a" = append; writes to existing file)
		access_mode ("r" = read)


read(byte_count)

write(data)

close()

os.rename() os.delete()


OS Module:

	import os

	os.listdir(".")		lists current directory
	os.getcwd()		list current working directory
	os.mkdir("Test")		create a directory called "Test"
	
	
	import glob
	for item in glob.glob(os.path.join(".", "*.py")):
		print item

			shows list of all files in current directory "." with *.py extension


Handles with Subprocess to execute OS commands:

	handle = subprocess.Popen("ls", stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE, close_fds=True)

	handle.stdout.read()

*********************************************************************************	

Scapy:

Ether() / IP() / TCP() / Data

git clone https://github.com/secdev/scapy.git

	ls()		shows all protocols scapy supports
	lsc()		List commands
	conf		Shows configuration options
	conf.route	shows routing table
	conf.route.add(host="10.1.1.1", gw="192.168.1.1")
			Adds route to routing table
			Does not add route to host machine, only in scapy
	conf.route.add(net="10.1.1.0/24", gw="192.168.1.1")
			Adds network route
			Does not add route to host machine, only in scapy


	Sniff packets with Scapy:
		>>> pkts = sniff(iface="eth0", count=3)
			#sniffs 3 packets on eth0
			#loads them into the variable pkts

		>>> pkts
		<Sniffed: TCP:0 UDP:0 ICMP:0 Other:3

		>>> pkts[0]
			#displays the first packet

		>>> pkts[0].show()
			#displays first packet in pretty format

		>>> hexdump(pkts[1])
			#shows hex / ascii table of packet

		>>> wrpcap("dump.pcap", pkts)
			#dumps all packets to pcap file
			#pkts[1] would be just the 1 packet

		>>> read_pkts = rdpcap("dump.pcap")
			#loads pcap contents into read_pkts
			#read_pkts will show info on what was sniffed, etc.

		>>> pkts = sniff(iface="eth0", filter="tcp", count=3)
			#filter above only captures TCP packets
			#filter= supports BPF filters exmamples:
			#filter="host 1.1.1.1"
			#filter="dst port 80"
			#filter="portrange 80-443"
			#filter="host 1.1.1.1 and not tcp port 22"

		>>> pkts = sniff(iface="eth0", count=30, prn=lambda x: x.summary())
			#shows packets as they come in.
			#.summary just shows basic info
			#.show will show full packets



		>>> export_object(pkts[0])
			#converts packet to Base64

		>>> newPkt = import_object()
			#copy and paste in a Base64 encoded packet
			# CTRL-D to save it
		>>> newPkt 
			#will show the packet information



		You can export packets you capture as strings:
		>>> capture_string = str(pkts[0])

		>>> capture_string
			#returns H


	Create packets / packet injection:
		All packets are in the form of:
			Ether() / IP() / TCP() / Data

		>>> pkt = IP(dst="google.com")
		
		>>> pkt	
		<IP dst=Net('google.com') |>

		>>> pkt.show()
			#returns more info

		>>> pkt = IP(dst="google.com")/ICMP()/"Jimmy was here"
		>>> pkt.show()
			#will show the IP, ICMP and raw Data created
		>>> send(pkt)
			#this sends the packet at layer 3
			#scapy adds everything for you (headers, etc.)
			#sendp (instead of send) is used to send layer 2, but you have to
			#  manually add interface

		>>> sendp(Ether()/IP(dst=google.com")/ICMP()/"Jimmy was here", iface="eth0", loop=1, inter=1)
			#sends ICMP packet on layer 2 because sendp was used
			#loop=1 causes the packet to be sent over and over in an infinite loop
			#inter=1 causes a 1 second delay between each packet sent

		Send and Receive Layer 2 and Layer 3
			Layer 3:
				sr()	returns answers and unanswered packets
				sr1()	returns only the response/answer

			Layer 2:
				srp()	returns answers and unanswered packets
				srp1()	returns only the response/answer or sent packet


		>>> sr(IP(dst="google.com")/ICMP()/"Jimmy was here")
		Begin emission:
		Finished sending 1 packets
		.........*
		Received 286 packets, got 1 answers, remain 0 packets
		(<Results: TCP: 0 UPD:0 ICMP:1 Other:0>, <Unanswered: TCP:0 UDP:0 ICMP:0 Other:0>)
			#this sends 1 ICMP packet on layer 3 and waits for response
		
		>>> response, no_response = _
			#the _ is the last response from above the "Results and Unanswered"
		>>> response
		<Results: TCP:0 UDP:0 ICMP:1 Other:0>
		>>> no_response
		<Unanswered: TCP:0 UDP:0 ICMP:0 Other:0>
		>>> response[0]
			#shows the echo-reply


		>>>sr(IP(dst="google.com"), timeout=5)
			#this example sends an IP packet but doesn't contain any TCP port information.
			#therefore, a response is never received. Scapy will listen forever by default.
			#timeout=5 causes it to stop listening after 5 seconds



*********************************************************************************

HTML Parsing

from bs4 import BeautifulSoup
import urllib

html = urllib.request.urlopen('http://www.securitytube.net/video/3000')

html

html.code

bt = BeautifulSoup(html.read(), "lxml")
bt.title
bt.title.string

Show meta tags one by one:
bt.meta
bt.meta.next
bt.meta.next.next
bt.meta.next.next.next....


find_all!!!!
show all meta tags at once:
allMetaTags = bt.find_all('meta')
allMetaTags
allMetaTags[0]
allMetaTags[1]

If allMetaTags[0] returns:
	<meta contents="text/html; charset=utf-8" http-equiv="Content-type"/>
you can parse that by doing this:
	allMetaTags[0]['content']
It will return:
	'text/html;charset=utf-8'

To get the other value returned from allMetaTags[0]:
	allMetaTags[0]['http-equiv']
	'Content-type'

Find all the links in the response:
find all a tags and then display the href

	allLinks = bt.find_all('a')

	len(allLinks)	#tells you how many links there are

	allLinks[0]
		<a href="/Login?mode=login">Login</a>

	allLinks[0].string 	#returns the text value
		'Login'

	allLinks[0]['href']	#returns the URL/URI
		'/Login?mode=login'

	Extract all links and Descriptions:
	for link in allLinks:
		print("URL: " + link['href'] + " Description: " + link.string)


Get all text from a response:
	bt.get_text()



Sample to scrape a response:
	import urllib
	from bs4 import BeautifulSoup

	httpResponse = urllib.request.urlopen('http://securitytube.net/video/3000')

	httpResponse.code	
		#should return a "200"

	html = httpResponse.read()
		#should return entire response assign to "html" variable

	html
		#should return entire response

	bs = BeautifulSoup(html, "lxml")
		#beautifulsoup variable "bs" on the html variable with the lxml parser

	description = bs.find('div', id='description')
		#sets description variable to the value that is defined in the response:
		#	<div id="description">

	description
		#should return everything inside the <div </div> tags

	Now if you want to find all links within the description you can do the following:
	allLinks = description.find_all('a')
	allLinks

	description.get_text()

Another example to scrap a response:
	import urllib
	from bs4 import BeautifulSoup

	httpResponse = urllib.request.urlopen('http://securitytube.net/video/3000')

	httpResponse.code	
		#should return a "200"

	html = httpResponse.read()
		#should return entire response assign to "html" variable

	html
		#should return entire response

	bs = BeautifulSoup(html, "lxml")
		#beautifulsoup variable "bs" on the html variable with the lxml parser

	videoLink = bs.find('iframe', { 'title' : 'YouTube video player' }
		#grabbing from response:
		# <iframe title "YouTube video player" src="http://youtube.com/3wagdaasfe"></iframe>
		# more options can be added inside the { } if needed

	videoLink
		#should return all the info inside the <iframe ... > </iframe> tags

	videoLink['src']
		#returns just the url 'http://youtube.com/3wagdaasfe'

Form Submission with Mechanize library (search box form):
	import mechanize
	
	br = mechanize.Browser()

	br.open('http://www.securitytube.net/video/3000')

	for X in br.forms():
		print(X)
			#prints all the forms in the page. Looks like this:
			# <GET http://www.securitytube.net/video/3000 application/x-www-form-urlencoded
  			# <TextControl(q=)>
  			# <SubmitButtonControl(<None>=) (readonly)>>
	
	br.select_form(nr=0)
		# nr=0 this selects the first form in the response., nr=1 would be the next and so on.

	br.form['q'] = 'defcon'
		# the 'q' is acquired from the <TextControl(q=)> above
		# defcon is the word we are putting in the form to submit

	br.submit()
		#submits the form
		#response is like this:
		#<response_seek_wrapper at 0x7fc1963f4850 whose wrapped object = <closeable_response at.....

	for link in br.links():
		print(link)
			#returns all the links in the response from the submission

	for link in br.links():
		print(link.url + ' : ' + link.text)
			#this returns the link and the text describing the link. i.e:
			#  http://bla.com/video.mp4 : Security Video



Form Submission with Mechanize library (login page):

	import mechanize
	
	br = mechanize.Browser()

	br.open('http://blah.com/login')

	for form in br.forms():
		print(form)
		#Response:
		#	<POST http://blah.com/login application/x-www-form-urlencoded
		#	   <TextControl(username=)>
		#	   <PasswordControl(password=)>
		#	   <SubmitControl(<None>=Login) (readonly)>>

	br.select_form(nr=0)
		#nr=0 means the first form

	br.form['username'] = 'jimmy'
	br.form['password'] = 'blah'

	br.submit()
		#response looks like this;
		#<response_seek_wrapper at 0x893823823 whose wrapped object = <closeable_response at 0x.....

	print(br.response().read())
		#should print entire response
		
	for link in br.links():
		print(link.url + ' : ' + link.text
			#this shows us all the links returned once we logged in 


	Now we are browsing as if we are in a web browser. In this case we are going to the "change password page"

	new_link = br.click_link(text='moodle[IMG]Change password')
		#in the response above for all the links we saw a link with this link.text 'moodle[IMG]Change password'

	br.open(new_link)
		#this "clicks" the link

	print(br.response().read())
		#print response to clicking the link

	for form in br.forms():
		print(form)
			#show forms for changing the password
			
		

XML Parsing with BeautifulSoup:
	#All tags in XML can be any name the author assigns
	#typically there are <item> <title> <description> <author> tags, stuff like that

	from bs4 import BeautifulSoup

	xml = open('sample.xml', 'r').read()
		#in this example I copied the XML response to a local file.

	bs = BeautifulSoup(xml, "xml")
		#tell beautifulsoup we are parsing an XML file
		#this step can be slow and long

	for item in bs.find_all('item'):
		print (item.title.string)
		print (item.link.string)
		print (item.description.string)
			#this prints the content between the <item><title> </title></item> tags and link and description



*********************************************************************************
Portable Executable

PE is the native file format for Windows

PE should have minimum 1 code and 1 data section

Codes Sections
	.text - executable instructions

Data Section
	.bss - uninitialized data i.e. static variables
	.rdata - read only data i.e. constants
	.data - all other variables

Export / Import Data
	.edata - name + address of export functions
	.idata - contains Import Address Table and others

Debug Section
	.debug - debug info for the file

Resource Section
	.rsrc - contains resource information
		resource hacker tool

Relocation Section
	.reloc - relocation information

Thread Local Storage Template
	.tls - template section for thread data storage


PE file library pefile:

	import pefile
	import pprint

	pe = pefile.PE('c:\\windows\\notepad.exe')
		#load notepad.exe for examination

	pe
		#returns something like this:
		#<pefile.PE instance at 0x00000149AC39D7B8>

	dir(pe)
		#show the structure of the file

	pprint.pprint(dir(pe))
		#pretty view of the output


	Select a header or object to look at:
	pe.DOS_HEADER
		#we see info about the DOS_HEADER but still difficult to read

	pprint.pprint(dir(pe.DOS_HEADER))
		#Returns header fields, etc.

	pe.DOS_HEADER.e_magic
		Should return MZ has the magic file header.

	hex(pe.DOS_HEADER.e_magic)
		#returns the HEX value which converted to ASCII would be ZM
		#its in Little Endian so you read it backwards
		#bytearray.fromhex("5a4d").decode() will convert to ZM 

	hex(pe.DOS_HEADER.e_lfanew)
		#tells us where the PE Header begins

	pprint.pprint(dir(pe.FILE_HEADER))
		#displays structure of the FILE HEADER; note the NumberOfSections 

	pe.FILE_HEADER.NumberOfSections
		#lists number of sections

	pprint.pprint(dir(pe.sections[0]))
		#note the "Name" and "SizeOfRawData"

	for section in pe.sections:
		print(section.Name)
		print(section.SizeOfRawData)
		print('\n')
			#returns all sections and their respective sizes


	UPX is a packer for packing files. Works on windows, linux, etc.
		https://upx.github.io/

		pack Windows Notepad to compare it against the original, non-packed notepad

		C:\Users\jtharel\Downloads\upx-3.96-win64\upx.exe -9 -o notepad-upx.exe c:\windows\notepad.exe
			# -9 		complress better
			# -o 		output file that has been packed
			# notepad.exe	program to pack

	pe2 = pefile.PE('C:\\Users\\jtharel\\notepad-upx.exe')
		#load in the new file
		#note the \\ in the path

	for section in pe2.sections:
		print(section.Name)
		print(section.SizeOfRawData)
		print('\n')

	pe.dump_info()
		#will dump everything

	pprint.pprint(pe.dump_info())


Disassemble Code with the Pydasm/libdasm module:
	#requires 32bit python and 32bit windows binary

	import pydasm
	instruction - pydasm.get_instruction('\x50', pydasm.MODE_32

	instruction
	<class __main__.Instruction at 0x01316C70>

	pydasm.get_instruction_string(instruction, pydasm.FORMAT_INTEL, 0)
	'push eax'

	
	instruction - pydasm.get_instruction('\x85\xC0', pydasm.MODE_32	
	'test eax,eax'

	pprint.pprint(dir(instruction)


pydbg module

	import pydbg
	dbg = pydbg.pydbg()
	dbg.enumerate_processes()





PEXPECT
	import pexpect
	id = pexpect.spawn('ssh jtharel@192.168.1.251')
		#command to run

	id.expect_exact('Password:')
	0
		#expect to see Password:, if 0 retuned it's a success

	id.sendline('password101!')
	13

	id.expect_exact('jtharel@MacBook-Pro ~ %')
	0

	id.sendline('ls')
	3

	id.expect_exact('jtharel@MacBook-Pro ~ %')
	0
		#this is required so that expect knows it is back at a command prompt

	id.before
		#this should show the output of the 'ls' command but it will be ugly

	for line in id.before.split(b'\n'):
	     print(line)
	Desktop/                    Library/                    Pictures/                   Virtual Machines.localized/
	Documents/                  Movies/                     Public/                     tools/
	Downloads/                  Music/                      Software/




*********************************************************************************

Python NMAP library

pip install python3-nmap

import nmap3

nmap = nmap3.Nmap()

results = nmap.scan_top_ports("192.168.1.99")

results


# nmap -O -sV 192.168.1.99. in python:
nmap = nmap3.NmapHostDiscovery()
results = nmap.nmap_portscan_only('192.168.1.99', args='-sV')


# nmap -O 192.168.1.99  in python:
nmap = nmap3.Nmap()
results = nmap.nmap_dns_brute_script("192.168.1.99")
 
# nmap -sV 192.168.1.99. in python:
nmap = nmap3.Nmap()
results = nmap.nmap_os_detection("192.168.1.99")	#must be root

#nmap sys scan
nmap = nmap3.NmapScanTechniques()
results = nmap.nmap_syn_scan('192.168.1.99')

#nmap tcp scan
nmap = nmap3.NmapScanTechniques()
results = nmap.nmap_tcp_scan('192.168.1.99')










			
		

						
